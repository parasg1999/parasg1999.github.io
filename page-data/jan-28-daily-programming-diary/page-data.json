{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/jan-28-daily-programming-diary","result":{"data":{"post":{"__typename":"MdxPost","slug":"/jan-28-daily-programming-diary","title":"Jan 28 - Daily Programming Diary","date":"28.01.2021","tags":[{"name":"Diary","slug":"diary"},{"name":"Programming","slug":"programming"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Jan 28 - Daily Programming Diary\",\n  \"date\": \"2021-01-28T00:00:00.000Z\",\n  \"tags\": [\"Diary\", \"Programming\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h5\", null, \"10:00\"), mdx(\"p\", null, \"I was doing the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/explore/challenge/card/january-leetcoding-challenge-2021/582/week-4-january-22nd-january-28th/3618/\"\n  }), \"Leetcode Challenge\"), \" last night but decided to do it in the morning instead. Now with my brain working in a better condition, I think it's time to solve the problem. \"), mdx(\"p\", null, \"Just get the number of bits in the current number, and multiply the answer till now with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2 ^ NO_OF_BITS\"), \" and take MOD.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp:title=concatenation-of-consecutive-binary-numbers.cpp\"\n  }), \"int MOD = 1000000007;\\nint countBits(unsigned int number) {\\n    return (int)log2(number) + 1;\\n}\\n\\nint concatenatedBinary(int n) {\\n    long long ans = 1;\\n    for (int i = 2; i <= n; i++) {\\n        int digits = countBits(i);\\n        while (digits--) {\\n            ans *= 2;\\n            ans %= MOD;\\n        }\\n        ans += i;\\n        ans %= MOD;\\n    }\\n\\n    return ans;\\n}\\n\")), mdx(\"p\", null, \"Time complexity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n logn)\"), \", space \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(1)\"), \".\"), mdx(\"p\", null, \"Time for Dijkstra's Algorithm now. I hope I can implement it.\"), mdx(\"h5\", null, \"12:17\"), mdx(\"p\", null, \"Finally! God it feels so good! I can't believe I effing did it. \"), mdx(\"p\", null, \"So, the approach right?\\nI am maintaining a vector \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"efforts\"), \" regarding the efforts (cost) to be put to go to a particular node.\\nThen inserting into set based on distance to get the minimum distance node. The vector \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"visited\"), \" tells whether the particular node has already been visited so as not to be stuck inside an infinite loop.\"), mdx(\"p\", null, \"So after getting the minimum distance node, check the neighbours and update their efforts if the current node is a better way to reach that node.\"), mdx(\"p\", null, \"Then update \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"min_dist\"), \" which stores the maximum of the minimum distance that need to be traversed at that point of time.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Problems faced\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I was updating visited as soon as I inserted anything into the set, instead it should've been done when erasing it from set.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Updating \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"min_dist\"), \" as soon as I track the neighbours but it checks the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"visited\"), \" property and then messes up the whole set.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Returning too early - As soon as the target node was removed from the set, I returned without giving the chance to actually update the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"min_dist\"), \". This is the part which is still a bit cloudy but it's probably because I'm not visiting a node until I track it's neighbours.\\nThis is related to the 2\", mdx(\"sup\", null, \"nd\"), \" issue.\")), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp:title=path-with-minimum-effort.cpp\"\n  }), \"int minimumEffortPath(vector<vector<int>> &heights) {\\n    int m = heights.size(), n = heights[0].size();\\n    int dx[4] = {1, 0, 0, -1};\\n    int dy[4] = {0, 1, -1, 0};\\n\\n    int min_dist = 0;\\n\\n    vector<vector<int>> efforts(m, vector<int>(n, INT_MAX)); // All distance INF initially\\n    vector<vector<bool>> visited(m, vector<bool>(n, false)); // No nodes visited initially\\n    set<pair<int, pair<int, int>>> s;                        // To get node with MIN effort\\n\\n    efforts[0][0] = 0; // SRC Node has distance 0\\n\\n    s.insert(make_pair(0, make_pair(0, 0)));\\n\\n    while (!s.empty())\\n    {\\n        auto p = *(s.begin());\\n\\n        int row = p.second.first;\\n        int col = p.second.second;\\n\\n        s.erase(s.begin());\\n        visited[row][col] = true; // Current Node has been visited\\n\\n        min_dist = max(min_dist, efforts[row][col]);\\n\\n        for (int i = 0; i < 4; i++) {\\n            int new_row = row + dx[i];\\n            int new_col = col + dy[i];\\n\\n            if (new_row < 0 || new_row >= m || new_col < 0 || new_col >= n) {\\n                continue;\\n            }\\n\\n            if (abs(heights.at(new_row).at(new_col) - heights[row][col]) < efforts.at(new_row).at(new_col) && !visited[new_row][new_col]) {\\n                auto f = s.find(make_pair(efforts.at(new_row).at(new_col), make_pair(new_row, new_col)));\\n                if (f != s.end()) {\\n                    s.erase(f);\\n                }\\n\\n                efforts.at(new_row).at(new_col) = abs(heights.at(new_row).at(new_col) - heights[row][col]);\\n\\n                s.insert(make_pair(efforts.at(new_row).at(new_col), make_pair(new_row, new_col)));\\n            }\\n        }\\n\\n        if (row == m - 1 && col == n - 1) return min_dist;\\n    }\\n    return 0;\\n}\\n\")), mdx(\"p\", null, \"Time complexity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(n*m + n*mlogn*m)\"), \" (Dijkstra's) and\\nspace complexity \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"O(m*n)\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"m\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" are the rows and columns respectively.\"), mdx(\"h5\", null, \"14:00\"), mdx(\"p\", null, \"Starting today's \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/explore/featured/card/january-leetcoding-challenge-2021/582/week-4-january-22nd-january-28th/3619/\"\n  }), \"Leetcode challenge\"), \".\\nPretty basic problem after the above one. :p\"), mdx(\"p\", null, \"Get the number of z in the string after accounting for the minimum number of a's to be inserted. Then add those z's. After that, add the character with the remaining value. Then remaining a's !\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-smallest-string-with-a-given-numeric-value.cpp\"\n  }), \"string getSmallestString(int n, int k) {\\n    k -= n;\\n    string a = \\\"\\\";\\n    int no_of_z = k / 25, j = 0;\\n    k %= 25;\\n    for (; j < no_of_z; j++) {\\n        a += \\\"z\\\";\\n    }\\n    if (a.length() != n) {\\n        a += ('a' + k);\\n    }\\n    for (; j < n - 1; j++) {\\n        a += \\\"a\\\";\\n    }\\n\\n    for (int i = 0; i < n / 2; i++) {\\n        swap(a[i], a[n - 1 - i]);\\n    }\\n\\n    return a;\\n}\\n\")), mdx(\"h5\", null, \"22:00\"), mdx(\"p\", null, \"gave Crio.do test on HackerRank. It was really difficult considering the fact that it was supposed to be a \\\"BASIC DSA TEST\\\". But anyway, I don't think I'll get selected for the second round.\"), mdx(\"p\", null, \"Have to go to Gurgaon tomorrow! Hoping for some good news there!\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Ciao!\")), mdx(\"h3\", null, \"EOD Checklist\"), mdx(\"ul\", {\n    \"className\": \"contains-task-list\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ul\"\n  }, {\n    \"className\": \"task-list-item\"\n  }), mdx(\"input\", _extends({\n    parentName: \"li\"\n  }, {\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  })), \" \", \"Leetcode January Challenge\"), mdx(\"li\", _extends({\n    parentName: \"ul\"\n  }, {\n    \"className\": \"task-list-item\"\n  }), mdx(\"input\", _extends({\n    parentName: \"li\"\n  }, {\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  })), \" \", \"This blog\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"10:00 I was doing the  Leetcode Challenge  last night but decided to do it in the morning instead. Now with my brain working in a better…","timeToRead":2,"banner":null}},"pageContext":{"slug":"/jan-28-daily-programming-diary","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}