{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/april-17-daily-programming-diary","result":{"data":{"post":{"__typename":"MdxPost","slug":"/april-17-daily-programming-diary","title":"April 17 - Daily Programming Diary","date":"17.04.2021","tags":[{"name":"Diary","slug":"diary"},{"name":"Programming","slug":"programming"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"April 17 - Daily Programming Diary\",\n  \"date\": \"2021-04-17T00:00:00.000Z\",\n  \"tags\": [\"Diary\", \"Programming\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h5\", null, \"12:30\"), mdx(\"p\", null, \"I started with today's \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/explore/challenge/card/april-leetcoding-challenge-2021/595/week-3-april-15th-april-21st/3710/\"\n  }), \"Leetcode Challenge\"), \".\\nThe question is to remove \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"k\"), \" identical consecutive letters from a string till it's no longer possble.\"), mdx(\"p\", null, \"The approach that I took is with stack and to store the counter, the stack is modifie to be a stack of pairs.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp:title=remove-all-adjacent-duplicates-in-string-ii.cpp\"\n  }), \"string removeDuplicates(string s, int k) {\\n    stack<pair<char, int>> stk;\\n\\n    for (auto c : s) {\\n        if (stk.empty()) {\\n            stk.push(make_pair(c, 1));\\n        } else {\\n            pair<char, int> temp = stk.top();\\n            if (temp.first == c) {\\n                if (temp.second == k - 1) stk.pop();\\n                else {\\n                    stk.pop();\\n                    stk.push(make_pair(c, temp.second + 1));\\n                }\\n            } else {\\n                stk.push(make_pair(c, 1));\\n            }\\n        }\\n    }\\n\\n    string ans = \\\"\\\";\\n    while (!stk.empty()) {\\n        pair<char, int> temp = stk.top();\\n        for (int i = 0; i < temp.second; i++) {\\n            ans = temp.first + ans;\\n        }\\n        stk.pop();\\n    }\\n\\n    return ans;\\n}\\n\")), mdx(\"h5\", null, \"16:20\"), mdx(\"p\", null, \"Trying the question for \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://leetcode.com/explore/challenge/card/april-leetcoding-challenge-2021/594/week-2-april-8th-april-14th/3704/\"\n  }), \"11th April\"), \".\"), mdx(\"p\", null, \"The simplest approach would be to calculate the depth of the tree and then iterate the tree for the second time and adding the nodes at the level. It would take two iterations.\"), mdx(\"p\", null, \"The next approach could be to store all the levels along with their sums in a map and then finding the sum associated with the maximum value. This would mean just a single itearion over the tree.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp:title=deepest-leaves-sum-with-map.cpp\"\n  }), \"unordered_map<int, int> umap;\\n\\nvoid traverse(TreeNode *root, int level) {\\n    if (!root) return;\\n\\n    umap[level] += root->val;\\n\\n    traverse(root->left, level + 1);\\n    traverse(root->right, level + 1);\\n}\\n\\nint deepestLeavesSum(TreeNode *root) {\\n    traverse(root, 0);\\n\\n    int mx = 0;\\n\\n    for (auto a : umap) {\\n        mx = max(a.first, mx);\\n    }\\n\\n    return umap[mx];\\n}\\n\")), mdx(\"p\", null, \"The next approach is to find the maximum depth value as we traverse, and then calculating the sum according to that.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-cpp:title=deepest-leaves-sum-with-one-iteration.cpp\"\n  }), \"int deepestLevel = 0, sum = 0;\\n\\nvoid traverse(TreeNode *root, int level) {\\n    if (!root) return;\\n\\n    if (level > deepestLevel) {\\n        deepestLevel = level;\\n        sum = 0;\\n    }\\n\\n    if (level == deepestLevel) {\\n        sum += root->val;\\n    }\\n\\n    traverse(root->left, level + 1);\\n    traverse(root->right, level + 1);\\n}\\n\\nint deepestLeavesSum(TreeNode *root) {\\n    traverse(root, 0);\\n\\n    return sum;\\n}\\n\")), mdx(\"h5\", null, \"21:30\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Okay, done for the day! Bye.\")), mdx(\"h3\", null, \"EOD Checklist\"), mdx(\"ul\", {\n    \"className\": \"contains-task-list\"\n  }, mdx(\"li\", _extends({\n    parentName: \"ul\"\n  }, {\n    \"className\": \"task-list-item\"\n  }), mdx(\"input\", _extends({\n    parentName: \"li\"\n  }, {\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  })), \" \", \"Raahee\"), mdx(\"li\", _extends({\n    parentName: \"ul\"\n  }, {\n    \"className\": \"task-list-item\"\n  }), mdx(\"input\", _extends({\n    parentName: \"li\"\n  }, {\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  })), \" \", \"Leetcode April Challenge\"), mdx(\"li\", _extends({\n    parentName: \"ul\"\n  }, {\n    \"className\": \"task-list-item\"\n  }), mdx(\"input\", _extends({\n    parentName: \"li\"\n  }, {\n    \"type\": \"checkbox\",\n    \"checked\": true,\n    \"disabled\": true\n  })), \" \", \"This blog\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"12:30 I started with today's  Leetcode Challenge .\nThe question is to remove  k  identical consecutive letters from a string till it's noâ€¦","timeToRead":1,"banner":null}},"pageContext":{"slug":"/april-17-daily-programming-diary","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}